{% extends "master.html" %}
{% load i18n %}


{% block breadcrumbs %}{% endblock %}

{% block content-header-subtitle %}{% trans "Manage Camunda process building blocks" %}{% endblock %}
{% block content-header-title %}{% trans "Camunda Worker Configuration" %}{% endblock %}
{% block content-header-explanation %}
{% blocktrans trimmed %}
    De Camunda Worker pikt taken op van Camunda processen.
    <br>
    In deze omgeving kan je bestaande functies/bouwblokken configureren voor je processen,
    en die opnemen in je procesmodel.
{% endblocktrans %}
{% endblock %}


{% block content %}
<article class="dashboard">
    <div class="dashboard__chart" id="piechart" data-url="{% url 'dashboard:dashboard-api:aggregate' %}">
    </div>

    <div class="dashboard__filter">
        <label class="dashboard__checkbox"><input type="checkbox" name="engine" value="camunda" checked/>Camunda</label>
        <label class="dashboard__checkbox"><input type="checkbox" name="engine" value="activiti" checked/>Activiti</label>
        <button type="submit" class="button button--submit" onclick="choose_data()">Show</button>
    </div>

    <p>
        <a href="{% url 'dashboard:task-list' %}">
            {% trans "View tasks details" %}
        </a>
    </p>
</article>

<article class="index">
    <a class="index__item" href="{% url 'tasks:taskmapping-list' %}">
        {% trans "View task mappings" %}
    </a>
</article>

<section class="index-admin">
    <span>Go to <a href="{% url 'admin:index' %}">admin</a></span>
</section>
{% endblock %}


{% block scripts %}
    <script src="https://d3js.org/d3.v5.min.js"></script>

    <script>

const request = (url, method='GET', body=undefined) => {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open(method, url);
        xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr.response);
            } else {
                reject(xhr.statusText);
            }
        };
        xhr.onerror = () => reject(xhr.statusText);
        xhr.send(body);
    });
};


const chart = (data) => {
    // set the dimensions and margins of the graph
    const width = 600,
        height = 300;

    const key = function(d){
      return d.data.label;
    };

    // The radius of the pieplot is half the width or half the height (smallest one)
    const radius = Math.min(width, height) / 2;

    // append the svg object to the div with id = piechart
    d3.select("#piechart")
      .selectAll("*")
      .remove();

    const svg = d3.select("#piechart")
      .append("svg")
        .attr("width", width)
        .attr("height", height)
      .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    // set the color scale
    const color = d3.scaleOrdinal()
      .domain(data)
      .range(['red', 'blue', 'yellow', 'green', 'purple']);

    // Compute the position of each group on the pie:
    const pie = d3.pie()
      .value(d => d.value);

    const data_ready = pie(d3.entries(data));

    // shape helper to build arcs:
    const arc = d3.arc()
      .innerRadius(radius*0.4)
      .outerRadius(radius*0.8);

    const outerArc = d3.arc()
      .innerRadius(radius * 0.9)
      .outerRadius(radius * 0.9);

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
      .selectAll('path')
      .data(data_ready)
      .enter()
      .append('path')
      .attr('d', arc)
      .attr('fill', d => color(d.data.key))
      .attr("stroke", "white")
      .style("stroke-width", "2px")
      .style("opacity", 0.7);

    // Now add the annotation. Use the centroid method to get the best coordinates
    const text = svg
      .selectAll('text')
      .data(data_ready)
      .enter()
      .append('text')
      // .attr("transform", d => "translate(" + arc.centroid(d) + ")")
      .call(text => text.filter(d => (d.endAngle - d.startAngle) > 0.25).append("tspan")
        .attr("y", "-0.7em")
        .attr("font-weight", "bold")
        .text(d => d.data.key))
      .call(text => text.filter(d => (d.endAngle - d.startAngle) > 0.25).append("tspan")
        .attr("x", 0)
        .attr("y", "0.7em")
        .text(d => d.data.value))
      .style("text-anchor", "middle");

      function midAngle(d){
    		return d.startAngle + (d.endAngle - d.startAngle)/2;
    	}

      text
        .attr("transform", function(d){
            const pos = outerArc.centroid(d);
            pos[0] = radius * 1.5 * (midAngle(d) < Math.PI ? 1 : -1);
            return "translate("+ pos +")";
        });

      // lines for labbels
      svg.selectAll("polyline")
        .data(data_ready)
        .enter()
        .append("polyline")
        .attr("points", function(d) {
            const pos = outerArc.centroid(d);
            pos[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);

            return [arc.centroid(d), outerArc.centroid(d), pos];
        })
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", "1px");

};


let data = {
  "items": {
  }
};


const choose_data = () => {
    const checkboxes = document.querySelectorAll('input[name=engine]');
    const engines = [...checkboxes]
      .filter(x => x.checked)
      .map(cb => cb.value);

    const use_data = engines.reduce((acc, engine) => {
      const engineData = data.items[engine] || {};
      Object.keys(engineData).forEach(status => {
        acc[status] = (acc[status] || 0) + engineData[status]
      });
      return acc;
    }, {});

    chart(use_data);

};

// get aggregated data
const container = document.getElementById('piechart');
const url = container.dataset.url;
request(url)
    .then(response => {
      data = JSON.parse(response);
      console.log(response);

      chart(data.total);
    });


</script>

{% endblock %}
